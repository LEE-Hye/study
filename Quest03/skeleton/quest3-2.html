<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<style>
		.square {
			width: 100px;
			height: 100px;
			border: 1px dashed black;
			display: inline-block;
			margin: 20px;
		}

		.enabled {
			background-color: limegreen;
			border: 1px solid black;
		}
	</style>
</head>

<body>
	<section class="row1">
		<div class="square"></div>
		<div class="square"></div>.
		<div class="square"></div>
		<div class="square"></div>
	</section>

	<section class="row2">
		<div class="square"></div>
		<div class="square"></div>
		<div class="square"></div>
		<div class="square"></div>
	</section>

	<script>

		// 선택 할 square 배열에 담기
		var rowSquares = document.getElementsByClassName('square');
		console.log(rowSquares)

		var Square = [];
		for (var i = 0; i < rowSquares.length; i++) {
			Square.push(rowSquares[i]);
		}

		console.log(Square);

		// row1의 square 배열
		var row1_square = Square.slice(0, 4);
		console.log(row1_square);

		// row2의 square 배열
		var row2_square = Square.slice(4, 8);
		console.log(row2_square);


		// [1]. 첫째 줄 박스 선택했을 때, 클릭한 박스 색 노란색<->흰색으로 토글

		// 1. foreach
		row1_square.forEach(function (change_background) {
			change_background.addEventListener('click', function () {
				console.log('클릭 잘 되나 확인');
				if (change_background.style.backgroundColor == 'yellow') {
					change_background.style.backgroundColor = 'white';
				} else {
					change_background.style.backgroundColor = 'yellow';
				}

			})
		})

		// 2. for
		// var는 함수 스코프로 새로운 함수가 생성되어야 스코프 생성
		// js엔진에서 for문이 돌고 비동기 콜백 함수 실행(for문이 돈 i값을 계속 유지 시키면서 콜백 해준다)하기 때문에
		// 반복문이 끝난 시점에서 바로 익명 함수를 실행 시키면 i = 5가 들어가게 되니
		// IIFE인 즉시 실행 함수를 사용해 반복문이 돌 때 같이 익명 함수도 실행하도록 만든다.
		// 클로저 : 내부 스코프에 i의 값이 없어 외부에 있는 값을 가져옴(외부 변수에 접근할 수 있는 함수)
		// 여기서  i값을 클로저 변수라 할 수 있음
		// 또는 ES6버전의 let을 사용하면 IIFE 사용 안 하고 할 수 있음 왜냐면 let은 for문 실행할 때 마다 계속 새로운 스코프를 생성하기 때문에 i가 달라
		// for (var i = 0; i < row1_square.length; i++) {
		// 	(function (i) {
		// 		row1_square[i].addEventListener('click', function () {
		// 			console.log(i);
		// 			console.log(row1_square[i]);
		// 			if (row1_square[i].style.backgroundColor == 'yellow') {
		// 				row1_square[i].style.backgroundColor = 'white';
		// 			} else {
		// 				row1_square[i].style.backgroundColor = 'yellow';
		// 			}
		// 		});
		// 	})(i);
		// }


		// iife : 즉시 실행 함수 표현 : 정의되자마자 즉시 실행
		// (function () {
		// code
		// })();



		// [2]. 둘째 줄 박스 선택했을 때, 클릭한 박스에 enabled라는 Class가 추가되거나 제거되어야 함
		row2_square.forEach(function (change_class) {
			change_class.addEventListener('click', function () {
				// console.log('클릭 잘 되는지');
				if (change_class.className == 'square') {
					// change_class.classList.add('enabled');
					change_class.className += ' enabled';
					console.log('추가했을 때 현재 클래스 네임 : ' + change_class.className);
				} else {
					// change_class.classList.remove('enabled');
					// change_class.className = 'square'; 모든 클래스가 square로 바뀜
					change_class.classList.replace('enabled','square');
					console.log('제거 했을 때 현재 클래스 네임 : ' + change_class.className);
				}
				// change_class.classList.toggle('enabled'); 클래스가 존재하면 제거, 없으면 추가
			})
		})
	</script>
</body>

</html>